#pragma  once
#include "Engine/Math/IntVec3.hpp"
#include "Engine/Renderer/Renderer.hpp"
#include "Game/Block.hpp"
#include "Engine/Core/Timer.hpp"
#include "Game/BlockIterator.hpp"
#include "Game/BlockTemplate.hpp"
#include <atomic>
#include <deque>

constexpr int XBITS = 4;
constexpr int YBITS = 4;
constexpr int ZBITS = 7;
constexpr int XSIZE = 1 << XBITS;
constexpr int YSIZE = 1 << YBITS;
constexpr int ZSIZE = 1 << ZBITS;
constexpr int CHUNK_SIZE = XSIZE * YSIZE * ZSIZE;
constexpr int XMASK = XSIZE - 1;
constexpr int YMASK = (YSIZE - 1) << XBITS;
constexpr int ZMASK = (ZSIZE - 1) << (XBITS + YBITS);
constexpr int VERTS_PER_BLOCK = 36;
constexpr int SEA_LEVEL = ZSIZE / 2;

constexpr float DIRT_TO_SAND_THRESHOLD = .4f;
constexpr float BEACH_HUMIDITY = .7f;
constexpr float WATER_TO_ICE_TEMP = .4f;
constexpr int MAX_SAND_HEIGHT = SEA_LEVEL + 8;
//needs to be odd number
constexpr int CAVE_LOCAL_MAXIMA_DIMENSIONS = 7;
constexpr float MAX_CAVE_RADIUS = 256.f;
constexpr float CAVE_SEGMENT_LENGTH = 16.f;
constexpr float CAVE_CAPSULE_RADIUS = 4.f;


enum class ChunkState
{
	MISSING,						//Optional only used in cases where we want to say that the chunk doesn't exist at all
	ON_DISK,						//Optional used only in cases where we want to say a chunk is missing, but it exists on disk
	CONSTRUCTING,					//[set by main thread] Initial state value during early construction

	ACTIVATING_QUEUED_LOAD,			//[set by main thread] Chunk has been adding to the loading queue
	ACTIVATING_LOADING,				//[set by disk thread] Chunk is still being loaded and populated by disk i/o thread
	ACTIVATING_LOAD_COMPLETE,		//[set by disk thread] Chunk is done loading and ready for the main thread to claim

	ACTIVATING_QUEUED_GENERATE,		//[set by main thread] Chunk has been added to the generating queue
	ACTIVATING_GENERATING,			//[set by generator thread] chunk block data is being generated by generator thread
	ACTIVATING_GENERATE_COMPLETE,	//[set by generator thread] Chunk is done generating and ready for the main thread to claim

	ACTIVE,							//[set by main thread] Chunk is in m_activeCunks; only main thread can touch it. Lighting, mesh building allowed

	DEACTIVATING_QUEUED_SAVE,		//[set by main thread] Chunk has been deactivated, and is being queued for save
	DEACTIVATING_SAVING,			//[set by disk thread] Chunk is being compressed and saved by disk i/o thread
	DEACTIVATING_SAVE_COMPLETE,		//[set by disk thread] Chunk has been saved and is ready for main thread to claim
	DECONSTRUCTING,					//[set by main thread] Chunk is being destroyed by main thread

	NUM_CHUNK_STATES
};

int GetChunkIndexFromCoords(IntVec3 chunkCoords);
int GetChunkIndexFromCoords(int x, int y, int z);
IntVec3 GetCoordsFromChunkIndex(int chunkIndex);

struct ColumnData
{
	int m_height = 0;
	float m_humidity = 0.f;
	float m_temperature = 0.f;
};

class Chunk
{
public:
	Chunk(IntVec2 coords);
	~Chunk();
	void Update(float deltaSeconds);
	void Render();
	void RebuildMesh();
	Block& GetBlockFromCoords(int x, int y, int z);
	int GetBlockIndexFromWorldPos(Vec3 const& worldPos);
	void RemoveNeighbors();
	void SaveChunkToDisk();
	bool RetrieveBlockDataFromDisk();
	void GenerateBlockData();
	void SpawnBlockTemplates();
	void GenerateCaves();
	void InitializeLightingData();
	void SetNeighboringChunks();
	void AddLoaclDirtyBlocksToGloablLightingQueue();
	Vec2 GetGlobalChunkCenterXY();
	Vec3 GetWorldPosFromBlockCoords(int blockX, int blockY, int blockZ);
	std::atomic<ChunkState> m_chunkState = ChunkState::CONSTRUCTING;
public:
	IntVec2 m_chunkCoords;
	bool m_isMeshDirty = true;
	bool m_needsSaving = false;
	bool m_chunkStepCompleted = false;
	Chunk* m_northNeighbor = nullptr;
	Chunk* m_eastNeighbor = nullptr;
	Chunk* m_southNeighbor = nullptr;
	Chunk* m_westNeighbor = nullptr;
	Block* m_blocks = nullptr;
	std::vector<Vertex_PCU> m_cpuVerts;
	std::vector<BlockTemplate> m_blockTemplatesForChunk;
private:
	void AddVertsForBlock(BlockType BlockType, IntVec3 const& blockPos);
	void AddVertsForBlock(BlockType BlockType, IntVec3 const& blockPos, std::vector<bool> const& visibleFaces);
	Rgba8 GetColorForBlock(BlockIterator blockIter);
	void CreateBlock(BlockType blockType, IntVec3 const& blockPos, int columnHeight);
	void DetermineBlockType(int x, int y, int z, std::vector<ColumnData> const& columnHeights);
	void AddBlockToMesh(int x, int y, int z, bool useHSR);
	bool ParseBlockDataVersion1(std::vector<unsigned char> const& bufferData);
	bool ParseBlockDataVersion2(std::vector<unsigned char> const& bufferData);
	bool ShouldColumnHaveTree(int globalX, int globalY);
	float GetTerrainHeightFromGlobalXY(int globalX, int globalY);
	float GetHumidityFromGlobalXY(int globalX, int globalY);
	float GetTemperatureFromGlobalXY(int globalX, int globalY);
	bool ShouldColumnHaveCaveOrigin(int columnX, int columnY);
	IntVec3 GetCaveOriginFromChunkCoords(IntVec2 const& chunkCoords);
	void AddDataForCave(std::map<IntVec3, std::vector<Vec3>>& mapsToCheck, IntVec3 const& caveOrigin);
	void CarveCaveInChunk(Vec3 const& capsuleStart, Vec3 const& capsuleEnd);

private:
	VertexBuffer* m_gpuVerts = nullptr;
	std::deque<BlockIterator> m_localDirtyLighting;
};